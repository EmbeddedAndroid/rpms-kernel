From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Mon, 16 Nov 2015 17:40:52 +0000
Subject: tty: amba-pl011: add support for 32-bit register access

Add support for 32-bit register accesses to the AMBA PL011 UART.  This
is needed for ZTE UARTs, which require 32-bit accesses as opposed to
the more normal 16-bit accesses.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Git-commit: 84c3e03bdd1146191b7222ed62a08512199a45c7
Git-repo: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
[cov@codeaurora.org: Backport to CentOS 7.2]
Signed-off-by: Christopher Covington <cov@codeaurora.org>
---
 drivers/tty/serial/amba-pl011.c | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
index 61512af..bb49704 100644
--- a/drivers/tty/serial/amba-pl011.c
+++ b/drivers/tty/serial/amba-pl011.c
@@ -74,6 +74,7 @@
 /* There is by now at least one vendor with differing details, so handle it */
 struct vendor_data {
 	unsigned int		ifls;
+	bool			access_32b;
 	unsigned int		lcrh_tx;
 	unsigned int		lcrh_rx;
 	bool			oversampling;
@@ -172,6 +173,7 @@ struct uart_amba_port {
 	unsigned int		lcrh_rx;	/* vendor-specific */
 	unsigned int		old_cr;		/* state during shutdown */
 	bool			autorts;
+	bool			access_32b;
 	unsigned int		fixed_baud;	/* vendor-set fixed baud rate */
 	char			type[12];
 #ifdef CONFIG_DMA_ENGINE
@@ -187,13 +189,20 @@ struct uart_amba_port {
 static unsigned int pl011_read(const struct uart_amba_port *uap,
 	unsigned int reg)
 {
-	return readw(uap->port.membase + reg);
+	void __iomem *addr = uap->port.membase + reg;
+
+	return uap->access_32b ? readl(addr) : readw(addr);
 }
 
 static void pl011_write(unsigned int val, const struct uart_amba_port *uap,
 	unsigned int reg)
 {
-	writew(val, uap->port.membase + reg);
+	void __iomem *addr = uap->port.membase + reg;
+
+	if (uap->access_32b)
+		writel(val, addr);
+	else
+		writew(val, addr);
 }
 
 /*
@@ -2381,6 +2390,7 @@ static int pl011_probe(struct amba_device *dev, const struct amba_id *id)
 	if (IS_ERR(uap->clk))
 		return PTR_ERR(uap->clk);
 
+	uap->access_32b = vendor->access_32b;
 	uap->vendor = vendor;
 	uap->lcrh_rx = vendor->lcrh_rx;
 	uap->lcrh_tx = vendor->lcrh_tx;
@@ -2462,6 +2472,7 @@ static int sbsa_uart_probe(struct platform_device *pdev)
 	if (!uap)
 		return -ENOMEM;
 
+	uap->access_32b = vendor_sbsa.access_32b;
 	uap->vendor	= &vendor_sbsa;
 	uap->fifosize	= 32;
 	uap->port.irq	= platform_get_irq(pdev, 0);
