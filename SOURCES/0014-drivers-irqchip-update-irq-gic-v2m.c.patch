From 7ec0bc4aab2291afdb7defbb730eb8d8e6d72d6b Mon Sep 17 00:00:00 2001
From: Phong Vo <pvo@apm.com>
Date: Tue, 5 Apr 2016 17:55:17 +0700
Subject: [PATCH 02/21] drivers:irqchip: update irq-gic-v2m.c

This patch is a backport of drivers/irqchip/irq-gic-v2m.c from upstream
as appropriate for kernel 4.2. It would resolve the issue of not
able to register to all PCI MSI frames supported by X-Gene 2.

Signed-off-by: Duc Dang <dhdang@apm.com>
Signed-off-by: Phong Vo <pvo@apm.com>
---
 drivers/irqchip/irq-gic-v2m.c | 238 +++++++++++++++++++++++-------------------
 1 file changed, 131 insertions(+), 107 deletions(-)

diff --git a/drivers/irqchip/irq-gic-v2m.c b/drivers/irqchip/irq-gic-v2m.c
index 9c019d1..827c640 100644
--- a/drivers/irqchip/irq-gic-v2m.c
+++ b/drivers/irqchip/irq-gic-v2m.c
@@ -51,8 +51,13 @@
 /* List of flags for specific v2m implementation */
 #define GICV2M_NEEDS_SPI_OFFSET		0x00000001
 
+static LIST_HEAD(v2m_nodes);
+static DEFINE_SPINLOCK(v2m_lock);
+
 struct v2m_data {
-	spinlock_t msi_cnt_lock;
+	struct list_head entry;
+	struct device_node *node;
+	struct msi_controller mchip;
 	struct resource res;	/* GICv2m resource */
 	void __iomem *base;	/* GICv2m virt address */
 	u32 spi_start;		/* The SPI number that MSIs start */
@@ -105,8 +110,8 @@ static void gicv2m_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)
 	struct v2m_data *v2m = irq_data_get_irq_chip_data(data);
 	phys_addr_t addr = v2m->res.start + V2M_MSI_SETSPI_NS;
 
-	msg->address_hi = (u32) (addr >> 32);
-	msg->address_lo = (u32) (addr);
+	msg->address_hi = upper_32_bits(addr);
+	msg->address_lo = lower_32_bits(addr);
 	msg->data = data->hwirq;
 
 	if (v2m->flags & GICV2M_NEEDS_SPI_OFFSET)
@@ -156,27 +161,30 @@ static void gicv2m_unalloc_msi(struct v2m_data *v2m, unsigned int hwirq)
 		return;
 	}
 
-	spin_lock(&v2m->msi_cnt_lock);
+	spin_lock(&v2m_lock);
 	__clear_bit(pos, v2m->bm);
-	spin_unlock(&v2m->msi_cnt_lock);
+	spin_unlock(&v2m_lock);
 }
 
 static int gicv2m_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,
 				   unsigned int nr_irqs, void *args)
 {
-	struct v2m_data *v2m = domain->host_data;
+	struct v2m_data *v2m = NULL, *tmp;
 	int hwirq, offset, err = 0;
 
-	spin_lock(&v2m->msi_cnt_lock);
-	offset = find_first_zero_bit(v2m->bm, v2m->nr_spis);
-	if (offset < v2m->nr_spis)
-		__set_bit(offset, v2m->bm);
-	else
-		err = -ENOSPC;
-	spin_unlock(&v2m->msi_cnt_lock);
+	spin_lock(&v2m_lock);
+	list_for_each_entry(tmp, &v2m_nodes, entry) {
+		offset = find_first_zero_bit(tmp->bm, tmp->nr_spis);
+		if (offset < tmp->nr_spis) {
+			__set_bit(offset, tmp->bm);
+			v2m = tmp;
+			break;
+		}
+	}
+	spin_unlock(&v2m_lock);
 
-	if (err)
-		return err;
+	if (!v2m)
+		return -ENOSPC;
 
 	hwirq = v2m->spi_start + offset;
 
@@ -203,7 +211,7 @@ static void gicv2m_irq_domain_free(struct irq_domain *domain,
 	irq_domain_free_irqs_parent(domain, virq, nr_irqs);
 }
 
-static struct irq_domain_ops gicv2m_domain_ops = {
+static const struct irq_domain_ops gicv2m_domain_ops = {
 	.alloc			= gicv2m_irq_domain_alloc,
 	.free			= gicv2m_irq_domain_free,
 };
@@ -224,17 +232,55 @@ static bool is_msi_spi_valid(u32 base, u32 num)
 	return true;
 }
 
-char gicv2m_msi_domain_name[] = "V2M-MSI";
-char gicv2m_domain_name[] = "GICV2M";
-static int __init gicv2m_init_one(struct irq_domain *parent,
+static void gicv2m_teardown(void)
+{
+	struct v2m_data *v2m, *tmp;
+
+	list_for_each_entry_safe(v2m, tmp, &v2m_nodes, entry) {
+		list_del(&v2m->entry);
+		kfree(v2m->bm);
+		iounmap(v2m->base);
+		of_node_put(v2m->node);
+		kfree(v2m);
+	}
+}
+
+static int gicv2m_allocate_domains(struct irq_domain *parent)
+{
+	struct irq_domain *inner_domain;
+	struct v2m_data *v2m;
+
+	v2m = list_first_entry_or_null(&v2m_nodes, struct v2m_data, entry);
+	if (!v2m)
+		return 0;
+
+	inner_domain = irq_domain_add_tree(NULL, &gicv2m_domain_ops, v2m);
+	if (!inner_domain) {
+		pr_err("Failed to create GICv2m domain\n");
+		return -ENOMEM;
+	}
+
+	inner_domain->parent = parent;
+	v2m->domain = pci_msi_create_default_irq_domain(v2m->node,
+						      &gicv2m_msi_domain_info,
+						      inner_domain);
+	if (!v2m->domain) {
+		pr_err("Failed to create MSI domain\n");
+		if (inner_domain)
+			irq_domain_remove(inner_domain);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int __init gicv2m_init_one(struct device_node *node,
 				  u32 spi_start, u32 nr_spis,
-				  struct resource *res,
-				  struct device_node *node,
-				  u32 msi_frame_id)
+                                  struct resource *res,
+                                  u32 msi_frame_id)
 {
 	int ret;
 	struct v2m_data *v2m;
-	struct irq_domain *inner_domain;
 
 	v2m = kzalloc(sizeof(struct v2m_data), GFP_KERNEL);
 	if (!v2m) {
@@ -242,13 +288,17 @@ static int __init gicv2m_init_one(struct irq_domain *parent,
 		return -ENOMEM;
 	}
 
-	v2m->base = ioremap(res->start, resource_size(res));
+	INIT_LIST_HEAD(&v2m->entry);
+	v2m->node = node;
+
+	memcpy(&v2m->res, res, sizeof(struct resource));
+
+	v2m->base = ioremap(v2m->res.start, resource_size(&v2m->res));
 	if (!v2m->base) {
 		pr_err("Failed to map GICv2m resource\n");
 		ret = -ENOMEM;
 		goto err_free_v2m;
 	}
-	memcpy(&v2m->res,res, sizeof(struct resource));
 
 	if (spi_start && nr_spis) {
 		v2m->spi_start = spi_start;
@@ -283,37 +333,12 @@ static int __init gicv2m_init_one(struct irq_domain *parent,
 		goto err_iounmap;
 	}
 
-	inner_domain = irq_domain_add_tree(NULL, &gicv2m_domain_ops, v2m);
-	if (!inner_domain) {
-		pr_err("Failed to create GICv2m domain\n");
-		ret = -ENOMEM;
-		goto err_free_bm;
-	}
-
-	inner_domain->parent = parent;
-	inner_domain->name = gicv2m_domain_name;
-	gicv2m_msi_domain_info.acpi_msi_frame_id = msi_frame_id;
-	v2m->domain = pci_msi_create_default_irq_domain(node, &gicv2m_msi_domain_info,
-							inner_domain);
-	if (!v2m->domain) {
-		pr_err("Failed to create MSI domain\n");
-		ret = -ENOMEM;
-		goto err_free_domains;
-	}
-
-	v2m->domain->name = gicv2m_msi_domain_name;
-
-	spin_lock_init(&v2m->msi_cnt_lock);
+	list_add_tail(&v2m->entry, &v2m_nodes);
 
+	pr_info("range%pR, SPI[%d:%d]\n", res,
+		v2m->spi_start, (v2m->spi_start + v2m->nr_spis - 1));
 	return 0;
 
-err_free_domains:
-	if (v2m->domain)
-		irq_domain_remove(v2m->domain);
-	if (inner_domain)
-		irq_domain_remove(inner_domain);
-err_free_bm:
-	kfree(v2m->bm);
 err_iounmap:
 	iounmap(v2m->base);
 err_free_v2m:
@@ -345,87 +370,86 @@ int __init gicv2m_of_init(struct device_node *node, struct irq_domain *parent)
 			break;
 		}
 
-		if (!of_property_read_u32(child, "arm,msi-base-spi", &spi_start) &&
+		if (!of_property_read_u32(child, "arm,msi-base-spi",
+					  &spi_start) &&
 		    !of_property_read_u32(child, "arm,msi-num-spis", &nr_spis))
-			pr_info("Overriding V2M MSI_TYPER (base:%u, num:%u)\n",
+			pr_info("DT overriding V2M MSI_TYPER (base:%u, num:%u)\n",
 				spi_start, nr_spis);
 
-		ret = gicv2m_init_one(parent, spi_start, nr_spis, &res, child, 0);
+		ret = gicv2m_init_one(child, spi_start, nr_spis, &res, 0);
 		if (ret) {
-			of_node_put(node);
+			of_node_put(child);
 			break;
 		}
-
-		pr_info("Node %s: range[%#lx:%#lx], SPI[%d:%d]\n", child->name,
-			(unsigned long)res.start, (unsigned long)res.end,
-			spi_start, (spi_start + nr_spis));
 	}
 
+	if (!ret)
+		ret = gicv2m_allocate_domains(parent);
+	if (ret)
+		gicv2m_teardown();
+
 	return ret;
 }
 
 #ifdef CONFIG_ACPI
-static struct acpi_madt_generic_msi_frame *msi_frame;
+static int acpi_num_msi;
 
 static int __init
-gic_acpi_parse_madt_msi(struct acpi_subtable_header *header,
-			const unsigned long end)
+acpi_parse_madt_msi(struct acpi_subtable_header *header,
+		    const unsigned long end)
 {
-	struct acpi_madt_generic_msi_frame *frame;
+	struct resource res;
+	u32 spi_start = 0, nr_spis = 0;
+	struct acpi_madt_generic_msi_frame *m;
 
-	frame = (struct acpi_madt_generic_msi_frame *)header;
-	if (BAD_MADT_ENTRY(frame, end))
+	m = (struct acpi_madt_generic_msi_frame *)header;
+	if (BAD_MADT_ENTRY(m, end))
 		return -EINVAL;
 
-	if (msi_frame)
-		pr_warn("Only one GIC MSI FRAME supported.\n");
-	else
-		msi_frame = frame;
+	res.start = m->base_address;
+	res.end = m->base_address + 0xfff;
 
-	return 0;
+	if (m->flags & ACPI_MADT_OVERRIDE_SPI_VALUES) {
+		spi_start = m->spi_base;
+		nr_spis = m->spi_count;
+
+		pr_info("ACPI overriding V2M MSI_TYPER (base:%u, num:%u)\n",
+			spi_start, nr_spis);
+	}
+
+	return (gicv2m_init_one(NULL, spi_start, nr_spis, &res, m->msi_frame_id));
 }
 
 int __init gicv2m_acpi_init(struct acpi_table_header *table,
-			    struct irq_domain *parent)
+                            struct irq_domain *parent)
 {
-	int ret = 0;
-	int count, i;
-	static struct acpi_madt_generic_msi_frame *cur;
-
-	count = acpi_parse_entries(ACPI_SIG_MADT, sizeof(struct acpi_table_madt),
-				   gic_acpi_parse_madt_msi, table,
-				   ACPI_MADT_TYPE_GENERIC_MSI_FRAME, 0);
-	if ((count <= 0) || !msi_frame) {
-		pr_debug("No valid ACPI GIC MSI FRAME exist\n");
-		return 0;
-	}
+	int ret;
 
-	for (i = 0, cur = msi_frame; i < count; i++, cur++) {
-		struct resource res;
-		u32 spi_start = 0, nr_spis = 0;
+	if (acpi_num_msi > 0)
+		return 0;
 
-		res.start = cur->base_address;
-		res.end = cur->base_address + 0x1000;
+	acpi_num_msi = acpi_parse_entries(ACPI_SIG_MADT,
+					  sizeof(struct acpi_table_madt),
+					  acpi_parse_madt_msi, table,
+					  ACPI_MADT_TYPE_GENERIC_MSI_FRAME, 0);
+	if (acpi_num_msi <= 0) {
+		goto err_out;
+	}
 
-		if (cur->flags & ACPI_MADT_OVERRIDE_SPI_VALUES) {
-			spi_start = cur->spi_base;
-			nr_spis = cur->spi_count;
+	ret = gicv2m_allocate_domains(parent);
+	if (ret)
+		goto err_out;
 
-			pr_info("ACPI overriding V2M MSI_TYPER (base:%u, num:%u)\n",
-				spi_start, nr_spis);
-		}
-
-		ret = gicv2m_init_one(parent, spi_start, nr_spis, &res, NULL,
-				      cur->msi_frame_id);
-		if (ret)
-			break;
+	return 0;
 
-		pr_info("MSI frame ID %u: range[%#lx:%#lx], SPI[%d:%d]\n",
-			cur->msi_frame_id,
-			(unsigned long)res.start, (unsigned long)res.end,
-			spi_start, (spi_start + nr_spis));
-	}
-	return ret;
+err_out:
+	gicv2m_teardown();
+	return -EINVAL;
+}
+#else /* CONFIG_ACPI */
+static int __init gicv2m_acpi_init(struct acpi_table_header *table,
+				   struct irq_domain *parent)
+{
+	return -EINVAL;
 }
-
 #endif /* CONFIG_ACPI */
-- 
2.6.0

